# CVerifier 软件需求规格说明书

| 文档版本 | 日期 | 作者 | 变更说明 |
|---------|------|------|---------|
| 0.1.0 | 2025-01-28 | CVerifier Team | 初始版本 |

---

## 目录

- [1. 引言](#1-引言)
  - [1.1 编写目的](#11-编写目的)
  - [1.2 项目背景](#12-项目背景)
  - [1.3 术语定义](#13-术语定义)
  - [1.4 参考资料](#14-参考资料)
- [2. 项目概述](#2-项目概述)
  - [2.1 项目目标](#21-项目目标)
  - [2.2 应用场景](#22-应用场景)
  - [2.3 技术路线](#23-技术路线)
- [3. 功能需求](#3-功能需求)
  - [3.1 核心功能](#31-核心功能)
  - [3.2 功能需求详细描述](#32-功能需求详细描述)
- [4. 非功能需求](#4-非功能需求)
  - [4.1 性能需求](#41-性能需求)
  - [4.2 可靠性需求](#42-可靠性需求)
  - [4.3 可用性需求](#43-可用性需求)
  - [4.4 可维护性需求](#44-可维护性需求)
  - [4.5 安全性需求](#45-安全性需求)
  - [4.6 兼容性需求](#46-兼容性需求)
- [5. 系统约束](#5-系统约束)
  - [5.1 技术约束](#51-技术约束)
  - [5.2 平台约束](#52-平台约束)
  - [5.3 依赖约束](#53-依赖约束)
- [6. 验收标准](#6-验收标准)
  - [6.1 MVP验收标准](#61-mvp验收标准)
  - [6.2 完整版验收标准](#62-完整版验收标准)
- [7. 附录](#7-附录)
  - [7.1 用例场景](#71-用例场景)
  - [7.2 测试用例清单](#72-测试用例清单)

---

## 1. 引言

### 1.1 编写目的

本文档是 CVerifier 项目的软件需求规格说明书（SRS），旨在：

1. **明确需求**：详细描述项目的功能和非功能需求
2. **指导开发**：为开发团队提供清晰的实现指南
3. **验收依据**：为项目验收提供明确的标准
4. **沟通桥梁**：在开发团队、用户和管理层之间建立共识

### 1.2 项目背景

#### 1.2.1 问题描述

C 语言作为系统级编程的主要语言，在带来高性能和灵活性的同时，也引入了许多内存安全漏洞：

- **缓冲区溢出**：导致任意代码执行
- **空指针解引用**：导致程序崩溃
- **内存泄漏**：导致资源耗尽
- **整数溢出**：导致逻辑错误和安全漏洞

传统的测试方法难以在开发阶段发现这些问题，而现有的静态分析工具存在误报率高、检测能力有限等问题。

#### 1.2.2 解决方案

CVerifier 是一个基于形式化验证技术的自动化工具，采用符号执行和抽象解释技术，能够在代码编译前精确地发现上述安全漏洞。

#### 1.2.3 项目意义

1. **提高软件质量**：在开发阶段发现潜在的安全漏洞
2. **降低开发成本**：减少后期修复 bug 的成本
3. **增强系统安全**：防止生产环境中的安全漏洞
4. **推广形式化方法**：让形式化验证技术更易于使用

### 1.3 术语定义

| 术语 | 定义 |
|------|------|
| **符号执行** | 一种程序分析技术，用符号值代替具体值来探索程序的所有可能执行路径 |
| **抽象解释** | 一种程序分析技术，通过抽象程序状态来近似计算程序的行为 |
| **SMT 求解器** | 可满足性模理论求解器，用于判定逻辑公式的可满足性 |
| **缓冲区溢出** | 向缓冲区写入的数据超过其容量，导致数据越界 |
| **空指针解引用** | 对值为 NULL 的指针进行解引用操作 |
| **内存泄漏** | 动态分配的内存未正确释放，导致内存资源耗尽 |
| **整数溢出** | 整数运算结果超出类型的表示范围 |
| **路径敏感** | 分析时考虑程序的执行路径 |
| **上下文敏感** | 分析时考虑函数调用的上下文 |
| **SSA** | 静态单赋值形式，一种中间表示 |

### 1.4 参考资料

1. IEEE Std 830-1998：软件需求规格说明书推荐实践
2. [LLVM Documentation](https://llvm.org/docs/)
3. [Z3 Theorem Prover](https://github.com/Z3Prover/z3)
4. [SV-COMP Benchmark](https://sv-comp.sosy-lab.org/)
5. [CWE (Common Weakness Enumeration)](https://cwe.mitre.org/)

---

## 2. 项目概述

### 2.1 项目目标

#### 2.1.1 总体目标

开发一个高效、准确、易用的 C 语言形式化验证工具，能够在工业应用中自动检测常见的安全漏洞。

#### 2.1.2 具体目标

1. **高准确率**：漏洞检测准确率 ≥ 80%，误报率 ≤ 20%
2. **高性能**：分析速度达到 1000 行代码/分钟
3. **易用性**：提供简洁的命令行接口和清晰的报告
4. **可扩展性**：模块化设计，支持添加新的漏洞检测器
5. **工业级质量**：支持完整的 C11/C17 标准

### 2.2 应用场景

#### 2.2.1 主要场景

**场景 1：软件开发**
```
用户角色：软件工程师
使用场景：在开发过程中检测代码中的安全漏洞
预期效果：在编译前发现潜在的安全问题
```

**场景 2：代码审查**
```
用户角色：代码审查员
使用场景：在代码审查时验证代码的安全性
预期效果：辅助审查员发现人工难以发现的漏洞
```

**场景 3：持续集成**
```
用户角色：DevOps 工程师
使用场景：在 CI/CD 流水线中集成自动化安全检测
预期效果：在代码提交时自动检测安全漏洞
```

**场景 4：安全审计**
```
用户角色：安全审计员
使用场景：对现有代码库进行安全审计
预期效果：发现历史遗留的安全漏洞
```

#### 2.2.2 目标用户

- **C/C++ 开发者**：希望在开发阶段发现漏洞
- **安全工程师**：需要进行安全审计
- **QA 工程师**：希望提高软件质量
- **科研人员**：研究形式化验证技术

### 2.3 技术路线

#### 2.3.1 核心技术

1. **符号执行**：探索程序的所有可能执行路径
2. **抽象解释**：快速近似程序行为，剪枝不可行路径
3. **混合分析**：结合符号执行和抽象解释的优势
4. **SMT 求解**：精确判断路径的可达性

#### 2.3.2 实现策略

- **混合方式**：核心自主实现 + 使用成熟库（LLVM、Z3）
- **渐进式开发**：从 MVP 到完整功能的分阶段实现
- **工业应用**：注重性能和可扩展性

---

## 3. 功能需求

### 3.1 核心功能

CVerifier 包含以下 8 大核心功能：

#### F1: C 代码解析

**功能描述**：解析 C 源代码，生成中间表示

**输入**：C 源文件（.c）
**输出**：LLIR 中间表示
**优先级**：P0（必须）

**子功能**：
- F1.1: 词法和语法分析
- F1.2: 抽象语法树（AST）构建
- F1.3: LLVM IR 生成
- F1.4: 控制流图（CFG）构建

#### F2: 符号执行

**功能描述**：对程序进行符号执行，探索所有可能的执行路径

**输入**：LLIR 函数
**输出**：符号执行状态和路径约束
**优先级**：P0（必须）

**子功能**：
- F2.1: 符号表达式管理
- F2.2: 路径探索（DFS/BFS/Hybrid）
- F2.3: 约束收集
- F2.4: 状态管理

#### F3: 抽象解释

**功能描述**：使用抽象域快速近似程序行为，剪枝不可行路径

**输入**：LLIR 函数
**输出**：抽象状态和约束
**优先级**：P1（重要）

**子功能**：
- F3.1: 抽象域管理（常量域、区间域等）
- F3.2: 不动点计算
- F3.3: 传递函数
- F3.4: Widening/Narrowing 操作

#### F4: 漏洞检测

**功能描述**：检测 C 代码中的安全漏洞

**输入**：符号执行状态和抽象状态
**输出**：漏洞报告
**优先级**：P0（必须）

**子功能**：

##### F4.1: 缓冲区溢出检测
- **检测目标**：数组越界、栈溢出、堆溢出、字符串函数溢出
- **检测方法**：边界检查 + 约束求解
- **优先级**：P0

##### F4.2: 空指针解引用检测
- **检测目标**：显式 NULL 解引用、可能的 NULL 解引用
- **检测方法**：指针状态跟踪 + 约束求解
- **优先级**：P0

##### F4.3: 内存泄漏检测
- **检测目标**：未释放的动态内存
- **检测方法**：内存分配/释放跟踪
- **优先级**：P1

##### F4.4: 整数溢出检测
- **检测目标**：有符号/无符号溢出、截断
- **检测方法**：算术运算检查
- **优先级**：P1

##### F4.5: 浮点溢出检测 ⭐新增
- **检测目标**：
  - IEEE 754 标准完整性支持
  - 浮点数上溢（Overflow → +Inf）
  - 浮点数下溢（Underflow → -Inf）
  - 非数字（NaN）产生和传播
  - 无穷大（Inf）产生和传播
  - 精度损失检测
  - 舍入误差检测
- **检测方法**：
  - IEEE 754 标准建模
  - 浮点异常状态跟踪
  - 精度分析
  - 特殊值（Inf/NaN）传播
- **优先级**：P1

##### F4.6: 除零错误检测 ⭐新增
- **检测目标**：
  - 整数除以零
  - 浮点数除以零
  - 模运算除零
- **检测方法**：分母约束求解
- **优先级**：P1

#### F5: 报告生成

**功能描述**：生成易读的分析报告

**输入**：漏洞列表和分析结果
**输出**：格式化报告
**优先级**：P0（必须）

**子功能**：
- F5.1: 控制台输出
- F5.2: SARIF 格式输出
- F5.3: JSON 格式输出
- F5.4: 错误轨迹生成
- F5.5: 修复建议生成

#### F6: 规约系统 ⭐新增

**功能描述**：支持用户编写的验证规约，实现代码与规约分离

**输入**：规约代码（C语言）、用户代码（C语言）
**输出**：规约验证结果
**优先级**：P0（必须）

**设计风格**：参考 Frama-C 的 ACSL（ANSI/ISO C Specification Language）

**子功能**：
- F6.1: 规约注解解析
  - 支持 ACSL 风格注解
  - 支持分离编译的规约库
- F6.2: 验证函数库
  - 提供预定义的验证函数
  - 支持用户自定义验证函数
- F6.3: 断言检查
  - 运行时断言验证
  - 静态断言验证
- F6.4: 不变量验证
  - 循环不变量
  - 类不变量（如果支持C++）
- F6.5: 规约隔离
  - 规约代码不污染业务代码
  - 规约代码独立编译

**规约注解示例**：
```c
/*@
  requires \valid_read(ptr + (0 .. size-1));
  requires \separated(ptr, oth);
  ensures \result == 0 || \result == 1;
*/
int check_buffer(char* ptr, int size, char* oth);

/*@ assert size > 0; */
/*@ assert \valid(ptr); */
```

#### F7: 插件系统 ⭐新增

**功能描述**：支持动态加载验证插件，扩展检测能力

**输入**：插件文件（.so/.dll）
**输出**：扩展的验证能力
**优先级**：P1

**子功能**：
- F7.1: 插件加载器
  - 动态加载共享库
  - 插件注册机制
  - 插件生命周期管理
- F7.2: 插件 API
  - 规约解析接口
  - 验证引擎接口
  - 报告生成接口
- F7.3: 插件发现
  - 自动发现插件目录
  - 配置文件指定插件

**插件示例**：
```cpp
// MyCustomChecker.so
class MyCustomChecker : public VerificationPlugin {
public:
    void load(const std::string& specFile) override;
    bool verify(LLIRFunction* func) override;
    std::string getName() const override { return "MyCustomChecker"; }
};
```

#### F8: Web UI 任务管理 ⭐新增

**功能描述**：提供 Web 界面进行任务管理和结果查看

**输入**：用户操作
**输出**：Web 页面
**优先级**：P1

**子功能**：
- F8.1: 任务管理
  - 创建验证任务
  - 查看任务状态
  - 任务优先级调整
  - 任务取消/重试
- F8.2: 进度监控
  - 实时进度显示
  - 资源使用监控
  - 日志查看
- F8.3: 代码编辑器
  - 集成 Monaco Editor
  - 语法高亮
  - 代码导航
  - 实时标注（显示漏洞位置）
- F8.4: 结果查看
  - 漏洞列表
  - 错误详情
  - 错误轨迹可视化
  - 报告导出
- F8.5: 协作功能
  - 多用户支持
  - 权限管理
  - 审计日志

**技术栈**：
- 前端：React + TypeScript
- 后端：C++ Crow（轻量级 Web 框架）
- 通信：WebSocket（实时） + REST API

### 3.2 功能需求详细描述

#### FR-001: C 代码解析

**需求描述**：工具必须能够解析符合 C11/C17 标准的 C 源代码

**功能规格**：
- 支持所有 C 基本类型（int, char, float, double, pointer 等）
- 支持数组、结构体、联合体
- 支持函数定义和声明
- 支持控制流语句（if, for, while, do-while, switch, break, continue, goto）
- 支持函数调用和递归
- 支持预处理器指令（#include, #define, #ifdef 等）
- 生成准确的行号信息

**验收标准**：
- [ ] 能够解析标准 C 代码文件
- [ ] 正确处理复杂的控制流
- [ ] 准确报告语法错误

#### FR-002: 中间表示生成

**需求描述**：将 C 代码转换为 LLIR 中间表示

**功能规格**：
- 保持源代码的语义
- 生成 SSA 形式
- 构建控制流图（CFG）
- 支持函数内联（小函数）

**验收标准**：
- [ ] LLIR 语义等价于源代码
- [ ] CFG 准确反映程序结构
- [ ] 支持至少 1000 行的函数转换

#### FR-003: 符号执行引擎

**需求描述**：实现前向符号执行引擎

**功能规格**：
- 支持符号变量和符号表达式
- 支持路径条件收集
- 支持 DFS/BFS/Hybrid 路径探索策略
- 支持状态克隆和回溯
- 支持路径深度限制

**验收标准**：
- [ ] 能够探索简单函数的所有路径
- [ ] 正确处理分支语句
- [ ] 支持至少 100 层的路径深度

#### FR-004: 缓冲区溢出检测

**需求描述**：检测各种类型的缓冲区溢出

**功能规格**：
- 检测静态数组越界访问
- 检测栈溢出
- 检测堆溢出
- 检测字符串函数溢出（strcpy, sprintf, gets 等）
- 生成溢出路径和反例

**验收标准**：
- [ ] 检测出提供的测试用例中 90% 的缓冲区溢出
- [ ] 误报率 ≤ 30%
- [ ] 生成可重现的错误轨迹

#### FR-005: 空指针解引用检测

**需求描述**：检测空指针解引用

**功能规格**：
- 检测显式 NULL 解引用
- 检测可能的 NULL 解引用（考虑分支条件）
- 跟踪指针的 NULL 状态
- 处理函数返回的指针

**验收标准**：
- [ ] 检测出提供的测试用例中 95% 的空指针解引用
- [ ] 误报率 ≤ 25%

#### FR-006: 内存泄漏检测

**需求描述**：检测内存泄漏

**功能规格**：
- 跟踪所有 malloc/new 分配
- 跟踪所有 free/delete 释放
- 在程序退出点报告未释放的内存
- 支持分配/释放配对检查

**验收标准**：
- [ ] 检测出提供的测试用例中 85% 的内存泄漏
- [ ] 误报率 ≤ 30%

#### FR-007: 整数溢出检测

**需求描述**：检测整数溢出

**功能规格**：
- 检测有符号整数溢出
- 检测无符号整数回绕
- 检测类型转换截断
- 检测位移溢出

**验收标准**：
- [ ] 检测出提供的测试用例中 80% 的整数溢出
- [ ] 误报率 ≤ 35%

#### FR-008: SMT 求解器集成

**需求描述**：集成 Z3 SMT 求解器进行约束求解

**功能规格**：
- 支持线性和非线性整数算术
- 支持位向量理论
- 支持数组理论
- 支持增量求解
- 支持模型提取

**验收标准**：
- [ ] 能够求解路径约束的可满足性
- [ ] 求解响应时间 < 1 秒（简单约束）
- [ ] 能够生成反例

#### FR-009: 报告生成

**需求描述**：生成多种格式的分析报告

**功能规格**：
- 控制台输出：彩色、分级、易读
- SARIF 格式：IDE 兼容、包含源代码片段
- JSON 格式：机器可读、结构化
- 包含漏洞位置、类型、严重程度
- 包含错误轨迹和反例

**验收标准**：
- [ ] 报告清晰易懂
- [ ] SARIF 报告能被 VS Code 正确显示
- [ ] JSON 报告包含完整的漏洞信息

#### FR-010: 命令行接口

**需求描述**：提供易用的命令行接口

**功能规格**：
- 支持单文件和多文件分析
- 支持配置文件
- 支持检查器启用/禁用
- 支持输出格式选择
- 支持超时和深度限制
- 提供详细的帮助信息

**验收标准**：
- [ ] 命令行选项完整
- [ ] 帮助信息清晰
- [ ] 支持通用的使用场景

---

## 4. 非功能需求

### 4.1 性能需求

#### NFR-PER-001: 分析速度

**需求描述**：工具必须在合理的时间内完成分析

**性能指标**：
- 分析速度：≥ 1000 行代码/分钟（MVP）
- 分析速度：≥ 5000 行代码/分钟（完整版）
- 简单函数分析时间：≤ 10 秒
- 复杂函数分析时间：≤ 5 分钟

**测量方法**：
使用 SV-COMP 基准测试集中的典型 C 程序进行测试

#### NFR-PER-002: 内存占用

**需求描述**：工具的内存占用必须合理

**性能指标**：
- 基础内存占用：≤ 100 MB
- 分析 1000 行代码：≤ 500 MB
- 分析 10000 行代码：≤ 2 GB

#### NFR-PER-003: 并发处理

**需求描述**：支持并发分析多个文件

**性能指标**：
- 支持至少 4 个文件并发分析
- 线性加速比：≥ 2.5x（4 线程）

### 4.2 可靠性需求

#### NFR-REL-001: 检测准确率

**需求描述**：工具必须准确检测漏洞

**可靠性指标**：
- 漏洞检测准确率：≥ 80%
- 误报率：≤ 20%
- 漏报率：≤ 20%

**测量方法**：
使用标注的测试集（SV-COMP、Test-Comp）进行评估

#### NFR-REL-002: 稳定性

**需求描述**：工具必须稳定运行，不崩溃

**可靠性指标**：
- 崩溃率：≤ 1%（在合法 C 代码上）
- 无限循环：0（必须支持超时机制）
- 内存泄漏：0（工具本身不应有内存泄漏）

### 4.3 可用性需求

#### NFR-USAB-001: 易用性

**需求描述**：工具必须易于使用

**可用性指标**：
- 新用户能在 10 分钟内完成首次分析
- 命令行选项直观易懂
- 错误信息清晰，提供修复建议
- 提供完整的文档和示例

#### NFR-USAB-002: 学习曲线

**需求描述**：降低学习成本

**可用性指标**：
- 提供 quick start 示例
- 提供常见问题 FAQ
- 提供视频教程（可选）

### 4.4 可维护性需求

#### NFR-MAINT-001: 代码质量

**需求描述**：代码必须易于维护

**可维护性指标**：
- 代码注释覆盖率：≥ 30%
- 函数复杂度（圈复杂度）：≤ 15
- 模块化设计，高内聚低耦合
- 遵循编码规范（Google C++ Style Guide）

#### NFR-MAINT-002: 可扩展性

**需求描述**：易于添加新功能

**可扩展性指标**：
- 支持插件式漏洞检测器
- 抽象域接口清晰
- 配置系统灵活

#### NFR-MAINT-003: 测试覆盖率

**需求描述**：必须有充足的测试

**可维护性指标**：
- 单元测试覆盖率：≥ 60%
- 集成测试用例：≥ 100 个
- 每个核心功能都有测试

### 4.5 安全性需求

#### NFR-SEC-001: 工具安全

**需求描述**：工具本身必须是安全的

**安全性指标**：
- 不执行用户代码（静态分析）
- 不依赖不可信的外部库
- 输入验证（防止恶意输入）

#### NFR-SEC-002: 数据隐私

**需求描述**：保护用户代码隐私

**安全性指标**：
- 不上传用户代码到远程服务器
- 分析结果仅在本地存储
- 支持清理临时文件

### 4.6 兼容性需求

#### NFR-COMP-001: 平台兼容

**需求描述**：支持主流操作系统

**兼容性指标**：
- Linux（Ubuntu 20.04+, CentOS 8+）
- Windows 10/11（通过 WSL 或原生）
- macOS 11+

#### NFR-COMP-002: 编译器兼容

**需求描述**：支持主流 C 编译器

**兼容性指标**：
- GCC 9+
- Clang 10+
- MSVC 2019+（Windows）

#### NFR-COMP-003: C 标准兼容

**需求描述**：支持 C 标准版本

**兼容性指标**：
- C99（完全支持）
- C11（完全支持）
- C17（完全支持）
- C23（部分支持，可选）

---

## 5. 系统约束

### 5.1 技术约束

#### C-001: 编程语言

**约束**：核心引擎必须使用 C++17 实现

**理由**：
- C++ 提供高性能
- 丰富的 STL 库
- 与 LLVM 和 Z3 的 C++ API 兼容

#### C-002: 依赖库

**约束**：必须使用 LLVM 15+ 和 Z3 4.12+

**理由**：
- LLVM 提供成熟的 C 语言前端
- Z3 是性能最好的开源 SMT 求解器

#### C-003: 构建系统

**约束**：必须使用 CMake 3.20+

**理由**：
- 跨平台支持
- 良好的 LLVM 集成
- 广泛使用

### 5.2 平台约束

#### P-001: 操作系统

**约束**：优先支持 Linux，其次 macOS 和 Windows

**理由**：
- Linux 是服务器和开发的主要平台
- 交叉平台支持增加开发成本

#### P-002: 硬件要求

**约束**：最低硬件要求

- CPU：双核处理器
- 内存：4 GB（推荐 8 GB）
- 磁盘：1 GB 可用空间

### 5.3 依赖约束

#### D-001: 外部依赖

**约束**：最小化外部依赖

**允许的依赖**：
- LLVM/Clang 15+
- Z3 4.12+
- 标准库（STL）

**禁止的依赖**：
- 闭源库
- 不稳定的库
- 有病毒式许可证的库

#### D-002: Python 版本

**约束**：Python 3.8+（用于辅助脚本）

**理由**：
- Python 2 已停止维护
- Python 3.8+ 引入了类型注解等特性

---

## 6. 验收标准

### 6.1 MVP验收标准

**时间节点**：第 6 周结束时

#### 功能验收

- [x] **FR-001**: 能够解析标准 C 代码
- [x] **FR-002**: 生成 LLIR 中间表示
- [x] **FR-003**: 实现基础符号执行引擎
- [x] **FR-004**: 检测简单数组越界
- [x] **FR-005**: 检测显式 NULL 指针解引用
- [x] **FR-009**: 生成控制台报告

#### 测试验收

- [ ] 通过至少 10 个基础测试用例
- [ ] 每种检测功能至少有 2 个测试用例
- [ ] 无致命 Bug

#### 文档验收

- [ ] 用户手册初版
- [ ] 安装指南
- [ ] API 文档（公共接口）

#### 性能验收

- [ ] 能够分析 ≥ 100 行的函数
- [ ] 简单函数分析时间 ≤ 30 秒

### 6.2 完整版验收标准

**时间节点**：第 12 周结束时

#### 功能验收

- [ ] 所有 P0 和 P1 功能全部实现
- [ ] 支持 4 类漏洞检测
- [ ] 支持多种报告格式
- [ ] 提供配置文件系统

#### 质量验收

- [ ] 准确率 ≥ 80%
- [ ] 误报率 ≤ 20%
- [ ] 分析性能：1000 行代码/分钟
- [ ] 单元测试覆盖率 ≥ 60%

#### 测试验收

- [ ] 通过至少 100 个集成测试用例
- [ ] 通过 SV-COMP 基准测试（子集）
- [ ] 无严重 Bug（P0、P1）
- [ ] P2/P3 Bug ≤ 10 个

#### 文档验收

- [ ] 完整的用户手册
- [ ] 开发者指南
- [ ] API 参考文档
- [ ] 示例和教程

#### 性能验收

- [ ] 分析 1000 行代码 ≤ 1 分钟
- [ ] 内存占用 ≤ 500 MB
- [ ] 支持 4 线程并发

---

## 7. 附录

### 7.1 用例场景

#### UC-001: 开发者检测缓冲区溢出

**主要角色**：软件开发工程师

**前置条件**：
- 已安装 CVerifier
- 有 C 源代码文件

**主要流程**：
1. 开发者编写包含缓冲区操作的 C 代码
2. 运行 `cverifier example.c`
3. 工具分析代码并生成报告
4. 查看报告，发现缓冲区溢出漏洞
5. 修复漏洞
6. 重新运行验证

**后置条件**：漏洞被修复

#### UC-002: CI/CD 集成

**主要角色**：DevOps 工程师

**前置条件**：
- 已安装 CVerifier
- 有 CI/CD 流水线

**主要流程**：
1. 在 CI 配置中添加 CVerifier 分析步骤
2. 代码提交时自动触发分析
3. 如果发现漏洞，构建失败
4. 开发者查看报告并修复
5. 修复后重新提交

**后置条件**：只有通过安全检测的代码才能合并

#### UC-003: 代码审查辅助

**主要角色**：代码审查员

**前置条件**：
- 待审查的代码
- 已安装 CVerifier

**主要流程**：
1. 下载待审查的代码
2. 运行 `cverifier --format=sarif src/*.c`
3. 在 IDE（VS Code）中查看 SARIF 报告
4. 查看每个漏洞的详细信息和代码位置
5. 结合人工审查，确认漏洞
6. 提出修改建议

**后置条件**：完成代码审查报告

### 7.2 测试用例清单

#### TC-BUF-001: 静态数组越界

**文件**：`tests/integration/buffer-overflow/test_buffer_overflow.c`

**测试用例数量**：10

**覆盖场景**：
- 简单越界访问
- 循环中的越界
- 条件分支中的越界
- 负索引
- 指针算术越界

#### TC-NUL-001: 空指针解引用

**文件**：`tests/integration/null-pointer/test_null_pointer.c`

**测试用例数量**：12

**覆盖场景**：
- 显式 NULL 解引用
- 未检查的指针
- malloc 失败
- 函数返回 NULL
- Use-after-free
- Double free

#### TC-LEAK-001: 内存泄漏

**文件**：`tests/integration/memory-leak/test_memory_leak.c`

**测试用例数量**：15

**覆盖场景**：
- 简单泄漏
- 循环中的泄漏
- 分支中的泄漏
- 函数返回泄漏
- realloc 泄漏
- 结构体泄漏

#### TC-INT-001: 整数溢出

**文件**：`tests/integration/integer-overflow/test_integer_overflow.c`

**测试用例数量**：20

**覆盖场景**：
- 无符号加法溢出
- 有符号加法溢出
- 乘法溢出
- 左移溢出
- 类型转换截断
- 除法错误

---

**文档结束**
